\section{Introduction}
\label{sec:introduction}
\vs{recheck the storyline and reframe where needed. Maybe stress more the security aspect and how TEE can help}

Data streams are more and more predominant in today's era of big data.
In the world of all-connected and the \emph{Internet-of-Things} (IoT), on market places, or elsewhere, data is continuously produced and consumed.
%The latest estimates predict a total of \vs{fill} TB/s to be analyzed efficiently and securely within the next 10 years.
However, such data streams requires more and more to be processed with reliability, scalability and security in mind.
This paper introduces \SYS{}, our initial work on a middleware framework for developing secure stream processing in the Cloud.
\SYS{} supports the implementation, deployment and the execution of stream processing tasks in distributed settings, from clusters to large-scale Cloud infrastructures.
\SYS{} adopts of message-oriented~\cite{mom}, responsive, resilient to faults middleware design.
Finally, it scales horizontally and vertically seamlessly \rp{SGX is limited in memory usage, which weakens the claim of vertical scalibity}.
%Its design This middleware is designed according to The Reactive Manifesto: it is responsive, resilient, elastic and message driven\cite{reactivemanifesto}.
Briefly, its design is inspired by the dataflow programming paradigm~\cite{uustalu_essence_2005}: the developer combines together several independent processing components (\emph{e.g.}, mappers, reducers, sinks, shufflers, joiners) to compose several processing pipes.% an easy way to implement a processing pipe.
The framework integrates an abstraction of the required deployment infrastructure.
It smoothly integrate with industrial-grade lightweight virtualization technologies (\emph{e.g.}, Docker~\cite{docker}).
%by deployment automation based on the Docker ecosystem
It aims to be secure: communication channels use the SSL protocol~\cite{freier2011secure} for data communication.
Finally, our design intends to exploit the secure processing capabilities offered by trusted hardware \emph{enclaves}, nowadays widely available into mass-market thanks to the introduction of Intel's \emph{Software Guard eXtensions} (SGX)~\cite{costan_intel} in the SkyLake processors~\cite{skylake}.
% and giving the ability to process datas in trusted enclaves by the integration of the Intel's Software Guard Extension (SGX) hardware.

Few mainstream solutions exist today for distributed stream processing.
Reactive Kafka~\cite{reactivekafka} allows stream processing atop of Apache Kafka~\cite{apachekafka}.
More recently, few open-source solutions (\emph{e.g.}, Apache Spark Streaming~\cite{apachesparkstreaming}, Apache Storm~\cite{apachestorm}, Infinispan~\cite{infinispan}) introduced APIs to allow developers to quickly setup and deploy stream processing infrastructures.
These systems rely on the \emph{Java Virtual Machine} (JVM)~\cite{lindholm2014java}.
However, SGX currently imposes a hard memory limit of 128\,MB to the enclaved code and data, at the cost of expensive encrypted memory paging mechanisms and serious performance leaks~\cite{pires_scbr:2016,brenner_securekeeper:_2016} when this limit is crossed.
\SYS{} proposes a lightweight and low-memory footprint framework that can fully execute within SGX enclaves.
We detail our implementation choices in Section~\ref{sec:implementation}.

%But one of our goals is to find out a software technology that can run in a SGX enclave, and the memory of the latter is limited to 96MB for the Intel Skylake processor (the first and only processor including SGX currently)\cite{costan_intel}.
%If the application running inside an enclave needs more memory, an expensive encrypted memory paging mechanism then is used, causing serious performance leaks~\cite{brenner_securekeeper:_2016}.
To recap, our \textbf{contributions} are the followings: (i) an architecture of \SYS{}, (ii) details of our implementation choices, and (iii) results of our preliminary evaluation based on a real-world dataset.

This paper is organized as follows.
The architecture of \SYS{} is described in Section~\ref{sec:architecture}.
Our implementation choices and an example of \SYS{} program are presented in Section~\ref{sec:implementation}.
Section~\ref{sec:eval} reports on our preliminary evaluation with respect to throughput and scalability results.
Before concluding, we wrap up by briefly describing our future work in Section~\ref{sec:future}.
