\section{Introduction}\label{sec:introduction}
%\vs{recheck the storyline and reframe where needed. Maybe stress more the security aspect and how TEE can help}

The data deluge imposed by a world of ever-connected devices, like the \emph{Internet of Things} (IoT), has fostered the emergence of novel data analytics and processing technologies to cope with the typical \emph{volume}, \emph{velocity} and \emph{variety} properties that characterize the big data era.
In particular, to support the continuous flow of information gathered by millions of IoT devices, data streams have emerged as a suitable paradigm to process data at scale.
However, as some of these data streams may convey sensitive information, stream processing requires to support end-to-end security mechanisms in order to prevent third-parties to access restricted data.

% Data streams are more and more predominant in today's era of big data.
% In the world of all-connected and the \emph{Internet-of-Things} (IoT), on market places, or elsewhere, data is continuously produced and consumed by a large diversity of stakeholders.
%The latest estimates predict a total of \vs{fill} TB/s to be analyzed efficiently and securely within the next 10 years.
% In this context, data streams are expected to be processed with a native support for reliability, scalability and security properties.
This paper introduces \SYS{}, our initial work on a middleware framework for developing and deploying secure stream processing on untrusted Cloud environments.
\SYS{} supports the implementation, deployment and execution of stream processing tasks in distributed settings, from large-scale clusters to multi-tenant Cloud infrastructures.
\SYS{} adopts a message-oriented~\cite{mom} middleware design.
While the current version of SGX (detailed in Section~\ref{sec:background}) restrains \SYS's vertical scalability, the middleware seamlessly scales horizontally. 
Infact, it is easy to add or remove processing nodes at any stage of the pipeline, for example to dynamically scale up or down with respect to the current workload.

%\rp{and vertically seamlessly. SGX is limited in memory usage, which weakens the claim of vertical scalability} \rr{I agree that vertical elasticity is hard to justify given the SGX constraints, unless we introduce a different kind of vertical scalability}.

The design of the system is inspired by the dataflow programming paradigm~\cite{uustalu_essence_2005}: the developer combines together several independent processing components (\emph{e.g.}, mappers, reducers, sinks, shufflers, joiners) to compose specific processing pipes.
The framework integrates an abstraction of the required deployment infrastructure.
\SYS{} smoothly integrates with industrial-grade lightweight virtualization technologies (\emph{e.g.}, Docker~\cite{docker}).
%by deployment automation based on the Docker ecosystem
It aims to be secure: communication channels use the SSL protocol~\cite{freier2011secure} for data communication.
Finally, our design exploits the secure processing capabilities offered by trusted hardware \emph{enclaves}, nowadays widely available into mass-market thanks to the introduction of Intel's \emph{Software Guard Extensions} (SGX)~\cite{costan_intel} in the SkyLake processors~\cite{intel:skylake}, therefore offering end-to-end security to the processed streams.
% and giving the ability to process datas in trusted enclaves by the integration of the Intel's Software Guard Extension (SGX) hardware.

A few mainstream solutions exist today for distributed stream processing.
\textsc{Reactive Kafka}~\cite{reactivekafka} allows stream processing atop of Apache \textsc{Kafka}~\cite{apachekafka}.
More recently, few open-source solutions (\emph{e.g.}, Apache \textsc{Spark Streaming}~\cite{apachesparkstreaming}, Apache \textsc{Storm}~\cite{apachestorm}, \textsc{Infinispan}~\cite{infinispan}) introduced APIs to allow developers to quickly setup and deploy stream processing infrastructures.
These systems rely on the \emph{Java Virtual Machine} (JVM)~\cite{lindholm2014java}.
However, SGX currently imposes a hard memory limit of 128\,MB to the enclaved code and data, at the cost of expensive encrypted memory paging mechanisms and serious performance leaks~\cite{pires_scbr:2016,brenner_securekeeper:_2016} when this limit is crossed.
Moreover, executing a fully-functional JVM inside an SGX enclave would currently consist in significant re-engineering efforts.
\SYS proposes a lightweight and low-memory footprint framework that can fully execute within SGX enclaves.
We detail our implementation choices in Section~\ref{sec:implementation}.

%But one of our goals is to find out a software technology that can run in a SGX enclave, and the memory of the latter is limited to 96MB for the Intel Skylake processor (the first and only processor including SGX currently)\cite{costan_intel}.
%If the application running inside an enclave needs more memory, an expensive encrypted memory paging mechanism then is used, causing serious performance leaks~\cite{brenner_securekeeper:_2016}.
To recap, our \textbf{contributions} are the followings: (i) we describe the design of \SYS, (ii) we provide details of our reference implementation, in particular on how to smoothly integrate our runtime inside an SGX enclave, and (iii) an extensive evaluation with micro-benchmarks as well as real-world dataset.

The remainder of this paper is organized as follows.
To better understand the design of \SYS, Section~\ref{sec:background} gives a brief introduction to today's SGX operating mechanisms.
The architecture of \SYS{} is described in Section~\ref{sec:architecture}.
Our implementation choices and an example of \SYS{} program are reported in Section~\ref{sec:implementation}.
Section~\ref{sec:eval} discusses our extensive evaluation, presenting a detailed analysis of micro-benchmark performances, as well as more comprehensive macro-benchmarks with real-world datasets.%, focusing on with respect to throughput and scalability results.
Before presenting our conclusions, Section~\ref{sec:future} briefly describes our future work.
